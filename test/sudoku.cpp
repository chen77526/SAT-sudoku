#include <iostream>
#include <fstream>
#include <cstring>
#include <vector>
#include "sat.h"
#include <ctime>

using namespace std;

class Gate{
public:
    Gate(unsigned i = 0): _gid(i) {}
    ~Gate() {}

    Var getVar() const { return _var; }
    void setVar(const Var& v) { _var = v; }

private:
    unsigned   _gid;  // for debugging purpose...
    Var        _var;
};

vector<Gate *> gates;
vector<vector<int> > input;
vector<vector<int> > nonoBlock;
short base[9][9][9] = {0};
int Index[4] = {0};
string types;

void getHint(string file){
    ifstream inputFile(file);
    char buffer;
    int one, two, thr, fou, fiv, six, sev, eig, nin;
    inputFile >> buffer;
    if (buffer == 'c') {
        types = "classic";
        while(inputFile >> one >> two >> thr >> fou >> fiv >> six >> sev >> eig >> nin) {
            input.push_back(vector<int> {one, two, thr, fou, fiv, six, sev, eig, nin});
        }
    }
    else if (buffer == 'h') {
        types = "hyper";
        while(inputFile >> one >> two >> thr >> fou >> fiv >> six >> sev >> eig >> nin) {
            input.push_back(vector<int> {one, two, thr, fou, fiv, six, sev, eig, nin});
        }
    }
    else {
        types = "nonomino";
        int counter = 0;
        while(counter < 9 && (inputFile >> one >> two >> thr >> fou >> fiv >> six >> sev >> eig >> nin)) {
            input.push_back(vector<int> {one, two, thr, fou, fiv, six, sev, eig, nin});
            ++counter;
        }
        while(inputFile >> one >> two >> thr >> fou >> fiv >> six >> sev >> eig >> nin) {
            nonoBlock.push_back(vector<int> {one, two, thr, fou, fiv, six, sev, eig, nin});
        }
    }
}

void initCircuit(SatSolver& s) {
    // initialize input pin
    for (size_t x = 0; x < 9; ++x) {
        for (size_t y = 0; y < 9; ++y) {
            // initialize for gates (including nine unit literals)
            for (size_t z = 0; z < 9; ++z) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
                base[x][y][z] = 81*x + 9*y + z;
            }
        }
    }
}

void genPointCheck(SatSolver& s) {
    int currentGatesIndex = gates.size();
    vector<int> tmp(9, 0);
    vector<int> tmp2(9);
    // There is at least one number in each entry
    for (size_t x = 0; x < 9; ++x) {
        fill(tmp2.begin(), tmp2.end(), 0);
        for (size_t y = 0; y < 9; ++y) {
            // generate gates for checking one row
            for (size_t z = 0; z < 8; ++z) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }
            
            // for 2-literals clauses
            for (size_t i = 0; i < 4; ++i) {
                s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[x][y][2*i]]->getVar(), false, gates[base[x][y][2*i+1]]->getVar(), false);
                currentGatesIndex++;
            }
            s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[base[x][y][8]]->getVar(), false);
            currentGatesIndex++;

            // for 4/5-literals clauses
            s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            currentGatesIndex++;
            s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 4]->getVar(), false, gates[gates.size() - 6]->getVar(), false);
            currentGatesIndex++;

            // for the last clause
            s.addOrCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
            currentGatesIndex++;
            tmp2[y] = currentGatesIndex - 1;
        }

        // merge 9 output generated by each column
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }

        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
            currentGatesIndex++;
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[tmp2[8]]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 4;
        tmp[x] = currentGatesIndex - 1;
    }

    // merge 9 column output into one output
    for (size_t n = 0; n < 8; ++n) {
        gates.push_back(new Gate(gates.size() + 1));
        Var v = s.newVar();
        gates[gates.size() - 1]->setVar(v);
    }
    for (size_t n = 1; n <= 4; ++n) {
        s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
        currentGatesIndex++;
    }
    s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    currentGatesIndex += 4;

    Index[0] = currentGatesIndex - 1;
}

void genColCheck(SatSolver& s) {
    int currentGatesIndex = gates.size();
    vector<int> tmp(9, 0);
    vector<int> tmp2(9);
    
    // Each number appears at most once in each col
    for (size_t y = 0; y < 9; ++y) {
        fill(tmp2.begin(), tmp2.end(), 0);
        for (size_t z = 0; z < 9; ++z) {
            // generate gates for checking one col
            for (size_t n = 0; n < 71; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }

            // C(9, 2) pairs of clauses
            for (size_t x = 0; x < 8; ++x) {
                for (size_t i = x+1; i < 9; ++i) {
                    s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[x][y][z]]->getVar(), true, gates[base[i][y][z]]->getVar(), true);
                    currentGatesIndex++;
                }
            }

            // each pair combines into a pair-pair clause
            for (size_t n = 0; n < 18; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (71 - 2*n)]->getVar(), false, gates[gates.size() - (71 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            // combine above pair-pair clauses into 8-variable clauses
            for (size_t n = 0; n < 9; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (35 - 2*n)]->getVar(), false, gates[gates.size() - (35 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            // combine all clause into one output
            for (size_t n = 0; n < 4; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (17 - 2*n)]->getVar(), false, gates[gates.size() - (17 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
            currentGatesIndex++;
            tmp2[z] = currentGatesIndex - 1;
        }

        // merge 9 value output into one output
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }
        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 8;
        tmp[y] = currentGatesIndex - 1;
    }
    
    // merge 9 col output into one output
    for (size_t n = 0; n < 8; ++n) {
        gates.push_back(new Gate(gates.size() + 1));
        Var v = s.newVar();
        gates[gates.size() - 1]->setVar(v);
    }
    for (size_t n = 1; n <= 4; ++n) {
        s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    }
    s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    currentGatesIndex += 8;

    Index[1] = currentGatesIndex - 1;
}

void genRowCheck(SatSolver& s) {
    int currentGatesIndex = gates.size();
    vector<int> tmp(9, 0);
    vector<int> tmp2(9);

    // Each number appears at most once in each row
    for (size_t x = 0; x < 9; ++x) {
        fill(tmp2.begin(), tmp2.end(), 0);
        for (size_t z = 0; z < 9; ++z) {
            // generate gates for checking one row
            for (size_t n = 0; n < 71; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }

            // C(9, 2) pairs of clauses
            for (size_t y = 0; y < 8; ++y) {
                for (size_t i = y+1; i < 9; ++i) {
                    s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[x][y][z]]->getVar(), true, gates[base[x][i][z]]->getVar(), true);
                    currentGatesIndex++;
                }
            }

            // each pair combines into a pair-pair clause
            for (size_t n = 0; n < 18; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (71 - 2*n)]->getVar(), false, gates[gates.size() - (71 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            // combine above pair-pair clauses into 8-variable clauses
            for (size_t n = 0; n < 9; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (35 - 2*n)]->getVar(), false, gates[gates.size() - (35 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            // combine all clause into one output
            for (size_t n = 0; n < 4; ++n) {
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (17 - 2*n)]->getVar(), false, gates[gates.size() - (17 - 2*n) + 1]->getVar(), false);
                currentGatesIndex++;
            }

            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            currentGatesIndex++;
            s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
            currentGatesIndex++;
            tmp2[z] = currentGatesIndex - 1;
        }

        // merge 9 value output into one output
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }
        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 8;
        tmp[x] = currentGatesIndex - 1;
    }

    // merge 9 row output into one output
    for (size_t n = 0; n < 8; ++n) {
        gates.push_back(new Gate(gates.size() + 1));
        Var v = s.newVar();
        gates[gates.size() - 1]->setVar(v);
    }
    for (size_t n = 1; n <= 4; ++n) {
        s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    }
    s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    currentGatesIndex += 8;

    Index[2] = currentGatesIndex - 1;
}

void genBlockCheck(SatSolver& s) {
    int currentGatesIndex = gates.size();
    int xIndex = 0;
    int yIndex = 0;
    vector<int> tmp(9, 0);
    vector<int> tmp2(9);

    if (types != "nonomino"){
        // Each number appears at most once in each 3x3 sub-grid
        // combine y-direction value(81) into one output
        for (size_t z = 0; z < 9; ++z) {
            fill(tmp2.begin(), tmp2.end(), 0);
            for (size_t row = 0; row < 3; ++row) {
                for (size_t col = 0; col < 3; ++col) {
                    // generate gates for checking one sub-grid in y-direction
                    for (size_t n = 0; n < 17; ++n) {
                        gates.push_back(new Gate(gates.size() + 1));
                        Var v = s.newVar();
                        gates[gates.size() - 1]->setVar(v);
                    }

                    for (size_t x = 0; x < 3; ++x) {
                        for (size_t y = 0; y < 3; ++y) {
                            for (size_t k = y+1; k < 3; ++k) {
                                s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[3*row + x][3*col + y][z]]->getVar(), true, gates[base[3*row + x][3*col + k][z]]->getVar(), true);
                                currentGatesIndex++;
                            }
                        }
                    }

                    for (size_t n = 1; n <= 4; ++n) {
                        s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[gates.size() - 18 + (2*n - 1)]->getVar(), false, gates[gates.size() - 18 + (2*n)]->getVar(), false);
                    }
                    s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
                    s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
                    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
                    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
                    currentGatesIndex += 8;
                    tmp2[3*row+col] = currentGatesIndex - 1;
                }
            }

            // merge 9 sub-grid output into one output
            for (size_t n = 0; n < 8; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }
            for (size_t n = 1; n <= 4; ++n) {
                s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
            }
            s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
            currentGatesIndex += 8;
            tmp[z] = currentGatesIndex - 1;
        }
        
        // merge 9 value output into one output
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }
        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 8;
        xIndex = currentGatesIndex;

        // combine x-direction value(243) into one output
        fill(tmp.begin(), tmp.end(), 0);
        fill(tmp2.begin(), tmp2.end(), 0);
        for (size_t z = 0; z < 9; ++z) {
            fill(tmp2.begin(), tmp2.end(), 0);
            for (size_t row = 0; row < 3; ++row) {
                for (size_t col = 0; col < 3; ++col) {
                    // generate gates for checking one sub-grid in y-direction
                    for (size_t n = 0; n < 53; ++n) {
                        gates.push_back(new Gate(gates.size() + 1));
                        Var v = s.newVar();
                        gates[gates.size() - 1]->setVar(v);
                    }

                    for (size_t x = 0; x < 3; ++x) {
                        for (size_t y = 0; y < 3; ++y) {
                            for (size_t k = x+1; k < 3; ++k) {
                                for (size_t l = 0; l < 3; ++l) {
                                    s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[3*row + x][3*col + y][z]]->getVar(), true, gates[base[3*row + k][3*col + l][z]]->getVar(), true);
                                    currentGatesIndex++;
                                    // cout << 3*row+x << " " << 3*col+y << "*" << 3*row+k << " " << 3*col+l << endl;
                                }
                            }
                        }
                    }

                    for (size_t n = 1; n <= 13; ++n) {
                        s.addAigCNF(gates[gates.size() - 27 + n]->getVar(), gates[gates.size() - 54 + (2*n - 1)]->getVar(), false, gates[gates.size() - 54 + (2*n)]->getVar(), false);
                    }
                    for (size_t n = 1; n <= 6; ++n) {
                        s.addAigCNF(gates[gates.size() - 14 + n]->getVar(), gates[gates.size() - 27 + (2*n - 1)]->getVar(), false, gates[gates.size() - 27 + (2*n)]->getVar(), false);
                    }
                    s.addAigCNF(gates[gates.size() - 7]->getVar(), gates[gates.size() - 27]->getVar(), false, gates[gates.size() - 14]->getVar(), false);
                    currentGatesIndex += 20;

                    for (size_t n = 1; n <= 3; ++n) {
                        s.addAigCNF(gates[gates.size() - 7 + n]->getVar(), gates[gates.size() - 14 + (2*n - 1)]->getVar(), false, gates[gates.size() - 14 + (2*n)]->getVar(), false);
                    }
                    s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
                    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 4]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
                    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
                    currentGatesIndex += 6;
                    tmp2[3*row+col] = currentGatesIndex - 1;
                    // cout << gates.size() << " " << currentGatesIndex << endl;
                }
            }

            // merge 9 sub-grid output into one output
            for (size_t n = 0; n < 8; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }
            for (size_t n = 1; n <= 4; ++n) {
                s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
            }
            s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
            currentGatesIndex += 8;
            tmp[z] = currentGatesIndex - 1;
        }

        // merge 9 value output into one output
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }
        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 8;
        yIndex = currentGatesIndex;
        
        gates.push_back(new Gate(gates.size() + 1));
        Var v = s.newVar();
        gates[gates.size() - 1]->setVar(v);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[xIndex - 1]->getVar(), false, gates[yIndex - 1]->getVar(), false);
        currentGatesIndex++;

        if (types == "hyper") {
            short hyper[4][9][9] = {0};
            fill(tmp.begin(), tmp.end(), 0);
            fill(tmp2.begin(), tmp2.end(), 0);

            // Select entries which are located in hyper sub-grid
            for (size_t i = 1; i < 9; i+=4) {
                for (size_t j = 1; j < 9; j+=4) {
                    for (size_t z = 0; z < 9; ++z) {
                        for (size_t x = 0; x < 3; ++x) {
                            for (size_t y = 0; y < 3; ++y) {
                                if (i == 1 && j == 1)
                                    hyper[0][3*x+y][z] = base[i+x][j+y][z];
                                else if (i == 1 && j == 5)
                                    hyper[1][3*x+y][z] = base[i+x][j+y][z];
                                else if (i == 5 && j == 1)
                                    hyper[2][3*x+y][z] = base[i+x][j+y][z];
                                else
                                    hyper[3][3*x+y][z] = base[i+x][j+y][z];
                            }
                        }
                    }
                }
            }

            // Each number appears at most once in each 3x3 hyper sub-grid
            for (size_t n = 0; n < 4; ++n) {
                fill(tmp2.begin(), tmp2.end(), 0);
                for (size_t z = 0; z < 9; ++z) {
                    // generate gates for checking one hyper sub-grid
                    for (size_t n = 0; n < 71; ++n) {
                        gates.push_back(new Gate(gates.size() + 1));
                        Var v = s.newVar();
                        gates[gates.size() - 1]->setVar(v);
                    }
                    
                    // C(9, 2) pairs of clauses
                    for (size_t i = 0; i < 8; ++i) {
                        for (size_t k = i+1; k < 9; ++k) {
                            s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[hyper[n][i][z]]->getVar(), true, gates[hyper[n][k][z]]->getVar(), true);
                            currentGatesIndex++;
                        }
                    }

                    // each pair combines into a pair-pair clause
                    for (size_t n = 0; n < 18; ++n) {
                        s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (71 - 2*n)]->getVar(), false, gates[gates.size() - (71 - 2*n) + 1]->getVar(), false);
                        currentGatesIndex++;
                    }

                    // combine above pair-pair clauses into 8-variable clauses
                    for (size_t n = 0; n < 9; ++n) {
                        s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (35 - 2*n)]->getVar(), false, gates[gates.size() - (35 - 2*n) + 1]->getVar(), false);
                        currentGatesIndex++;
                    }

                    // combine all clause into one output
                    for (size_t n = 0; n < 4; ++n) {
                        s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (17 - 2*n)]->getVar(), false, gates[gates.size() - (17 - 2*n) + 1]->getVar(), false);
                        currentGatesIndex++;
                    }

                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
                    currentGatesIndex++;
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
                    currentGatesIndex++;
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
                    currentGatesIndex++;
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
                    currentGatesIndex++;
                    tmp2[z] = currentGatesIndex - 1;
                }

                // merge 9 value output into one output
                for (size_t n = 0; n < 8; ++n) {
                    gates.push_back(new Gate(gates.size() + 1));
                    Var v = s.newVar();
                    gates[gates.size() - 1]->setVar(v);
                }
                for (size_t n = 1; n <= 4; ++n) {
                    s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
                }
                s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
                s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
                s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
                s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
                currentGatesIndex += 8;
                tmp[n] = currentGatesIndex - 1;
            }

            // merge 4 sub-grid output into one output
            for (size_t n = 0; n < 4; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }
            s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[0]]->getVar(), false, gates[tmp[1]]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[tmp[2]]->getVar(), false, gates[tmp[3]]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[yIndex]->getVar(), false);
            currentGatesIndex += 4;
        }
    }
    else {
        short nonomino[9][9][9] = {0};
        short times[9] = {0};
        // Select entries which are located in each sub-grid
        for (size_t x = 0; x < 9; ++x) {
            for (size_t y = 0; y < 9; ++y) {
                for (size_t z = 0; z < 9; ++z) {
                    nonomino[nonoBlock[x][y]][times[nonoBlock[x][y]]][z] = base[x][y][z];
                }
                ++times[nonoBlock[x][y]];
            }
        }

        // Each number appears at most once in each 3x3 hyper sub-grid
        for (size_t n = 0; n < 9; ++n) {
            fill(tmp2.begin(), tmp2.end(), 0);
            for (size_t z = 0; z < 9; ++z) {
                // generate gates for checking one hyper sub-grid
                for (size_t n = 0; n < 71; ++n) {
                    gates.push_back(new Gate(gates.size() + 1));
                    Var v = s.newVar();
                    gates[gates.size() - 1]->setVar(v);
                }
                
                // C(9, 2) pairs of clauses
                for (size_t i = 0; i < 8; ++i) {
                    for (size_t k = i+1; k < 9; ++k) {
                        s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[nonomino[n][i][z]]->getVar(), true, gates[nonomino[n][k][z]]->getVar(), true);
                        currentGatesIndex++;
                    }
                }

                // each pair combines into a pair-pair clause
                for (size_t n = 0; n < 18; ++n) {
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (71 - 2*n)]->getVar(), false, gates[gates.size() - (71 - 2*n) + 1]->getVar(), false);
                    currentGatesIndex++;
                }

                // combine above pair-pair clauses into 8-variable clauses
                for (size_t n = 0; n < 9; ++n) {
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (35 - 2*n)]->getVar(), false, gates[gates.size() - (35 - 2*n) + 1]->getVar(), false);
                    currentGatesIndex++;
                }

                // combine all clause into one output
                for (size_t n = 0; n < 4; ++n) {
                    s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (17 - 2*n)]->getVar(), false, gates[gates.size() - (17 - 2*n) + 1]->getVar(), false);
                    currentGatesIndex++;
                }

                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
                currentGatesIndex++;
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
                currentGatesIndex++;
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
                currentGatesIndex++;
                s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
                currentGatesIndex++;
                tmp2[z] = currentGatesIndex - 1;
            }

            // merge 9 value output into one output
            for (size_t n = 0; n < 8; ++n) {
                gates.push_back(new Gate(gates.size() + 1));
                Var v = s.newVar();
                gates[gates.size() - 1]->setVar(v);
            }
            for (size_t n = 1; n <= 4; ++n) {
                s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
            }
            s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
            s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
            currentGatesIndex += 8;
            tmp[n] = currentGatesIndex - 1;
        }

        // merge 9 sub-grid output into one output
        for (size_t n = 0; n < 8; ++n) {
            gates.push_back(new Gate(gates.size() + 1));
            Var v = s.newVar();
            gates[gates.size() - 1]->setVar(v);
        }
        for (size_t n = 1; n <= 4; ++n) {
            s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
        }
        s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
        s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
        currentGatesIndex += 8;
    }

    Index[3] = currentGatesIndex - 1;
}

void genProofModel(SatSolver& s) {
    // Allocate and record variables; No Var ID for POs
    genPointCheck(s);
    genColCheck(s);
    genRowCheck(s);
    genBlockCheck(s);
    
    for (size_t n = 0; n < 2; ++n) {
        gates.push_back(new Gate(gates.size() + 1));
        Var v = s.newVar();
        gates[gates.size() - 1]->setVar(v);
    }
    s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[Index[0]]->getVar(), false, gates[Index[1]]->getVar(), false);
    s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[Index[2]]->getVar(), false, gates[Index[3]]->getVar(), false);
}

void reportResult(const SatSolver& solver, bool result) {   
    string answer = "";
    solver.printStats();
    cout << (result? "SAT" : "UNSAT") << endl;
    if (result) {
        for (size_t i = 0; i < 9; ++i) {
            for (size_t j = 0; j < 9; ++j) {
                bool flag = false;
                for (size_t k = 0; k < 9; ++k) {
                    if (solver.getValue(gates[base[i][j][k]]->getVar()) == 1 && !flag) {
                        answer += (to_string(k+1) + " ");
                        flag = true;
                    }
                    else if (solver.getValue(gates[base[i][j][k]]->getVar()) == 1 && flag) {
                        answer += "What?";
                    }
                }
            }
            answer += '\n';
        }
        cout << answer << endl;
    }
}

int main(int argc, char** argv) {
    getHint(argv[1]);

    time_t starttime, endtime;
    starttime = clock();
    SatSolver solver;
    solver.initialize();
    initCircuit(solver);

    genProofModel(solver);

    bool result;
    Var newV = solver.newVar();
    solver.addAigCNF(newV, gates[gates.size() - 1]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
    solver.assumeRelease();  // Clear assumptions
    solver.assumeProperty(newV, true);

    int counter = 0;
    for (size_t i = 0; i < 9; ++i) {
        for (size_t j = 0; j < 9; ++j) {
            if(input[i][j] != 0) {
                solver.assumeProperty(gates[base[i][j][input[i][j] - 1]]->getVar(), true);
                ++counter;
            }
        }
    }
    result = solver.assumpSolve();
    reportResult(solver, result);
    endtime = clock();
    cout << "Total clues: " << counter << endl;
    cout << "Total time: " << (endtime - starttime) / CLOCKS_PER_SEC << endl;
}


    // ***** genPointCheck another constraint *****

    // // There is "at most" one number in each entry
    // fill(tmp.begin(), tmp.end(), 0);
    // fill(tmp2.begin(), tmp2.end(), 0);
    // for (size_t x = 0; x < 9; ++x) {
    //     fill(tmp2.begin(), tmp2.end(), 0);
    //     for (size_t y = 0; y < 9; ++y) {
    //         for (size_t n = 0; n < 71; ++n) {
    //             gates.push_back(new Gate(gates.size() + 1));
    //             Var v = s.newVar();
    //             gates[gates.size() - 1]->setVar(v);
    //         }
            
    //         // C(9, 2) pairs of clauses
    //         for (size_t z = 0; z < 8; ++z) {
    //             for (size_t k = z+1; k < 9; ++k) {
    //                 s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[x][y][z]]->getVar(), true, gates[base[x][y][k]]->getVar(), true);
    //                 currentGatesIndex++;
    //             }
    //         }

    //         // each pair combines into a pair-pair clause
    //         for (size_t n = 0; n < 18; ++n) {
    //             s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (71 - 2*n)]->getVar(), false, gates[gates.size() - (71 - 2*n) + 1]->getVar(), false);
    //             currentGatesIndex++;
    //         }

    //         // combine above pair-pair clauses into 8-variable clauses
    //         for (size_t n = 0; n < 9; ++n) {
    //             s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (35 - 2*n)]->getVar(), false, gates[gates.size() - (35 - 2*n) + 1]->getVar(), false);
    //             currentGatesIndex++;
    //         }

    //         // combine all clause into one output
    //         for (size_t n = 0; n < 4; ++n) {
    //             s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - (17 - 2*n)]->getVar(), false, gates[gates.size() - (17 - 2*n) + 1]->getVar(), false);
    //             currentGatesIndex++;
    //         }

    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 9]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    //         currentGatesIndex++;
    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //         currentGatesIndex++;
    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //         currentGatesIndex++;
    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
    //         currentGatesIndex++;
    //         tmp2[y] = currentGatesIndex - 1;
    //     }
    //     // merge 9 row output into one output
    //     for (size_t n = 0; n < 8; ++n) {
    //         gates.push_back(new Gate(gates.size() + 1));
    //         Var v = s.newVar();
    //         gates[gates.size() - 1]->setVar(v);
    //     }
    //     for (size_t n = 1; n <= 4; ++n) {
    //         s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
    //     }
    //     s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    //     currentGatesIndex += 8;
    //     tmp[x] = currentGatesIndex - 1;
    // }
    // // merge 9 column output into one output
    // for (size_t n = 0; n < 8; ++n) {
    //     gates.push_back(new Gate(gates.size() + 1));
    //     Var v = s.newVar();
    //     gates[gates.size() - 1]->setVar(v);
    // }
    // for (size_t n = 1; n <= 4; ++n) {
    //     s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    // }
    // s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    // currentGatesIndex += 8;
    // // cout << gates.size() << " " << currentGatesIndex << endl;
    
    // gates.push_back(new Gate(gates.size() + 1));
    // Var v = s.newVar();
    // gates[gates.size() - 1]->setVar(v);
    // s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[mark]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
    // currentGatesIndex++;




    // ***** genColCheck another constraint *****

    // // Each number appears "at least" once in each col
    // for (size_t y = 0; y < 9; ++y) {
    //     fill(tmp2.begin(), tmp2.end(), 0);
    //     for (size_t z = 0; z < 9; ++z) {
    //         // generate gates for checking one col
    //         for (size_t x = 0; x < 8; ++x) {
    //             gates.push_back(new Gate(gates.size() + 1));
    //             Var v = s.newVar();
    //             gates[gates.size() - 1]->setVar(v);
    //         }
            
    //         // for 2-literals clauses
    //         for (size_t i = 0; i < 4; ++i) {
    //             s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[2*i][y][z]]->getVar(), false, gates[base[2*i+1][y][z]]->getVar(), false);
    //             currentGatesIndex++;
    //         }
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[base[8][y][z]]->getVar(), false);
    //         currentGatesIndex++;

    //         // for 4/5-literals clauses
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //         currentGatesIndex++;
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 4]->getVar(), false, gates[gates.size() - 6]->getVar(), false);
    //         currentGatesIndex++;

    //         // for the last clause
    //         s.addOrCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
    //         currentGatesIndex++;
    //         tmp2[z] = currentGatesIndex - 1;
    //     }

    //     // merge 9 output generated by each column
    //     for (size_t n = 0; n < 8; ++n) {
    //         gates.push_back(new Gate(gates.size() + 1));
    //         Var v = s.newVar();
    //         gates[gates.size() - 1]->setVar(v);
    //     }

    //     for (size_t n = 1; n <= 4; ++n) {
    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
    //         currentGatesIndex++;
    //     }
    //     s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[tmp2[8]]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    //     currentGatesIndex += 4;
    //     tmp[y] = currentGatesIndex - 1;
    //     // cout << currentGatesIndex << " " << gates.size() << endl;
    // }

    // // merge 9 column output into one output
    // for (size_t n = 0; n < 8; ++n) {
    //     gates.push_back(new Gate(gates.size() + 1));
    //     Var v = s.newVar();
    //     gates[gates.size() - 1]->setVar(v);
    // }
    // for (size_t n = 1; n <= 4; ++n) {
    //     s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    //     currentGatesIndex++;
    // }
    // s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    // currentGatesIndex += 4;




    // ***** genRowCheck another constraint *****

    // // Each number appears at least once in each row
    // for (size_t x = 0; x < 9; ++x) {
    //     fill(tmp2.begin(), tmp2.end(), 0);
    //     for (size_t z = 0; z < 9; ++z) {
    //         // generate gates for checking one row
    //         for (size_t y = 0; y < 8; ++y) {
    //             gates.push_back(new Gate(gates.size() + 1));
    //             Var v = s.newVar();
    //             gates[gates.size() - 1]->setVar(v);
    //         }
            
    //         // for 2-literals clauses
    //         for (size_t i = 0; i < 4; ++i) {
    //             s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[base[x][2*i][z]]->getVar(), false, gates[base[x][2*i+1][z]]->getVar(), false);
    //             currentGatesIndex++;
    //         }
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[base[x][8][z]]->getVar(), false);
    //         currentGatesIndex++;

    //         // for 4/5-literals clauses
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //         currentGatesIndex++;
    //         s.addOrCNF(gates[currentGatesIndex]->getVar(), gates[gates.size() - 4]->getVar(), false, gates[gates.size() - 6]->getVar(), false);
    //         currentGatesIndex++;

    //         // for the last clause
    //         s.addOrCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 3]->getVar(), false, gates[gates.size() - 2]->getVar(), false);
    //         currentGatesIndex++;
    //         tmp2[z] = currentGatesIndex - 1;
    //     }

    //     // merge 9 output generated by each row
    //     for (size_t n = 0; n < 8; ++n) {
    //         gates.push_back(new Gate(gates.size() + 1));
    //         Var v = s.newVar();
    //         gates[gates.size() - 1]->setVar(v);
    //     }

    //     for (size_t n = 1; n <= 4; ++n) {
    //         s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
    //         currentGatesIndex++;
    //     }
    //     s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[gates.size() - 5]->getVar(), false, gates[tmp2[8]]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    //     currentGatesIndex += 4;
    //     tmp[x] = currentGatesIndex - 1;
    //     // cout << currentGatesIndex << " " << gates.size() << endl;
    // }

    // // merge 9 column output into one output
    // for (size_t n = 0; n < 8; ++n) {
    //     gates.push_back(new Gate(gates.size() + 1));
    //     Var v = s.newVar();
    //     gates[gates.size() - 1]->setVar(v);
    // }
    // for (size_t n = 1; n <= 4; ++n) {
    //     s.addAigCNF(gates[currentGatesIndex]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    //     currentGatesIndex++;
    // }
    // s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    // currentGatesIndex += 4;




    // ***** genBlockCheck another constraint *****

    // vector<int> tmp3(9);
    // // Each number appears at least once in each 3x3 sub-grid
    // for (size_t z = 0; z < 9; ++z) {
    //     fill(tmp2.begin(), tmp2.end(), 0);
    //     for (size_t row = 0; row < 3; ++row) {
    //         for (size_t col = 0; col < 3; ++col) {
    //             fill(tmp3.begin(), tmp3.end(), 0);
    //             for (size_t x = 0; x < 3; ++x) {
    //                 for (size_t y = 0; y < 3; ++y) {
    //                     tmp3[3*x+y] = base[3*row + x][3*col + y][z];
    //                 }
    //             }

    //             // merge 9 grid output into one output
    //             for (size_t n = 0; n < 8; ++n) {
    //                 gates.push_back(new Gate(gates.size() + 1));
    //                 Var v = s.newVar();
    //                 gates[gates.size() - 1]->setVar(v);
    //             }
    //             for (size_t n = 1; n <= 4; ++n) {
    //                 s.addOrCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp3[2*(n-1)]]->getVar(), false, gates[tmp3[2*(n-1) + 1]]->getVar(), false);
    //             }
    //             s.addOrCNF(gates[gates.size() - 4]->getVar(), gates[tmp3[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    //             s.addOrCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //             s.addOrCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //             s.addOrCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    //             currentGatesIndex += 8;
    //             tmp2[3*row+col] = currentGatesIndex - 1;
    //         }
    //     }

    //     // merge 9 sub-grid output into one output
    //     for (size_t n = 0; n < 8; ++n) {
    //         gates.push_back(new Gate(gates.size() + 1));
    //         Var v = s.newVar();
    //         gates[gates.size() - 1]->setVar(v);
    //     }
    //     for (size_t n = 1; n <= 4; ++n) {
    //         s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp2[2*(n-1)]]->getVar(), false, gates[tmp2[2*(n-1) + 1]]->getVar(), false);
    //     }
    //     s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp2[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    //     s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    //     currentGatesIndex += 8;
    //     tmp[z] = currentGatesIndex - 1;
    //     // cout << currentGatesIndex << " " << gates.size() << endl;
    // }
    // // merge 9 value output into one output
    // for (size_t n = 0; n < 8; ++n) {
    //     gates.push_back(new Gate(gates.size() + 1));
    //     Var v = s.newVar();
    //     gates[gates.size() - 1]->setVar(v);
    // }
    // for (size_t n = 1; n <= 4; ++n) {
    //     s.addAigCNF(gates[gates.size() - 9 + n]->getVar(), gates[tmp[2*(n-1)]]->getVar(), false, gates[tmp[2*(n-1) + 1]]->getVar(), false);
    // }
    // s.addAigCNF(gates[gates.size() - 4]->getVar(), gates[tmp[8]]->getVar(), false, gates[gates.size() - 5]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 3]->getVar(), gates[gates.size() - 8]->getVar(), false, gates[gates.size() - 7]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 2]->getVar(), gates[gates.size() - 6]->getVar(), false, gates[gates.size() - 4]->getVar(), false);
    // s.addAigCNF(gates[gates.size() - 1]->getVar(), gates[gates.size() - 2]->getVar(), false, gates[gates.size() - 3]->getVar(), false);
    // currentGatesIndex += 8;